1. Identify the panel in opensearch-mixin/panels.libsonnet and determine its type (stat, barGauge, timeSeries, table, etc.)
  2. Locate the legacy reference panel:
    - Find the corresponding dashboard in opensearch-mixin-legacy/dashboards/
    - Extract the panel JSON by title
    - This becomes the source of truth for all comparisons
  3. Compare and update the signal definition:

  3. a. Examine the target expression in the legacy JSON panel's targets[0].expr field

  3. b. Identify the signal used in the current panel (e.g., signals.cluster.cluster_status)

  3. c. Find the signal definition in the appropriate signals file (e.g., opensearch-mixin/signals/cluster.libsonnet)

  3. d. Update the signal properties to match the legacy expression:
    - type: Set to 'gauge', 'counter', or 'raw'
        - Use 'raw' if you need full control over the expression
      - Use 'gauge' or 'counter' if using the signal framework's aggregation
    - aggLevel: Controls the aggregation scope
        - 'group' → aggregates by job,opensearch_cluster (uses queriesSelectorGroupOnly)
      - 'instance' → aggregates by job,opensearch_cluster,node (uses queriesSelector)
      - 'none' → no automatic aggregation wrapper
    - aggFunction: The aggregation function to use
        - 'min', 'max', 'avg', 'sum' → generates min by(...), max by(...), etc.
    - aggKeepLabels: Additional labels to keep in aggregation (e.g., ['type'])
    - legendCustomTemplate: Must match the legendFormat from legacy JSON
        - Example: '{{opensearch_cluster}}', '{{node}}', '{{type}}'
      - IMPORTANT: No spaces around label names: '{{index}}' NOT '{{ index }}'
    - IMPORTANT - Selector choice (queriesSelector vs queriesSelectorGroupOnly):
        - Examine the label selectors in the legacy JSON's metric selector (the part in curly braces)
      - Use %(queriesSelectorGroupOnly)s if the selector ONLY includes:
            - opensearch_cluster!=""
        - job=~"$job"
        - opensearch_cluster=~"$opensearch_cluster"
        - Example: opensearch_fs_path_total_bytes{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster"}
      - Use %(queriesSelector)s if the selector ALSO includes node filtering:
            - All of the above PLUS node=~"$node"
        - Example: opensearch_os_cpu_percent{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster",node=~"$node"}
      - Rule of thumb:
            - If aggregating BY node (e.g., sum by(node, job, opensearch_cluster)) but NOT filtering by node in the selector → use queriesSelectorGroupOnly
        - If filtering by node in the selector → use queriesSelector

  e. Compare generated vs legacy expression:
    - Signal with aggLevel: 'group', aggFunction: 'min' generates:
    min by(job,opensearch_cluster) (opensearch_metric{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster"})
    - If the legacy has additional wrappers like sum(max by (type) (...)), use withExprWrappersMixin() in the panel

  f. Update the panel's signal usage if needed:
    - Basic: signals.cluster.signal_name.asTarget()
    - With wrappers: signals.cluster.signal_name.withExprWrappersMixin(['sum(', ')']).asTarget()
    - Multiple wrappers can be nested: withExprWrappersMixin(['sum(', ')'])
  4. Compare and update missing panel configuration options in the current libsonnet, specifically:
    - Missing options properties (varies by panel type - see below)
    - Missing standardOptions properties (color mode, mappings, thresholds mode, overrides)
    - Missing target properties (intervalFactor, interval, instant)
  5. Update the libsonnet panel definition to include all missing properties using the appropriate grafonnet helper methods based on panel type. Use the actual values from the reference panel - the examples below are just to show the
  syntax:

  5. For all panel types:
    - Use g.query.prometheus.withIntervalFactor(2) for intervalFactor (use actual value from reference)
    - Use g.query.prometheus.withInterval('1m') for interval (use actual value from reference)
    - Use g.query.prometheus.withInstant(true) for instant queries (use actual value from reference)
    - Use g.panel.[TYPE].standardOptions.color.withMode('thresholds') for color mode (use actual value from reference)
    - ALWAYS add g.panel.[TYPE].standardOptions.thresholds.withMode('absolute') (use actual value from reference)
    - ALWAYS add g.panel.[TYPE].standardOptions.withOverrides([]) if it's an empty array in reference

  For mappings:
    - If the reference panel has an empty mappings array, use:
    + g.panel.[TYPE].standardOptions.withMappings([])
    - If the panel has value mappings, use the ValueMap builder pattern with the actual mapping values from the reference panel:
    + g.panel.[TYPE].standardOptions.withMappings([
    g.panel.[TYPE].standardOptions.mapping.ValueMap.withType()
    + g.panel.[TYPE].standardOptions.mapping.ValueMap.withOptions({
      '0': {index: 0, text: 'Green'},  // Use actual values from reference
      '1': {index: 1, text: 'Yellow'},
      '2': {index: 2, text: 'Red'},
    }),
  ])
    - Note: The options hash with specific keys is unavoidable - that's how Grafana mappings work.

  For overrides:
    - ALWAYS use the fieldOverride builder methods instead of hardcoded data structures
    - If the reference panel has an empty overrides array, use:
    + g.panel.[TYPE].standardOptions.withOverrides([])
    - If the panel has overrides, use the fieldOverride builder pattern:
    + g.panel.[TYPE].standardOptions.withOverrides([
    g.panel.[TYPE].fieldOverride.byRegexp.new('/pattern/')  // or byName, byType, byQuery
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('custom.axisSoftMax', 100)
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('custom.drawStyle', 'points')
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('unit', 'percent'),
  ])
    - Available override matchers: byRegexp, byName, byType, byQuery (byFrameRefID), byValue
    - Use withProperty(id, value) to add individual properties
    - Use withPropertiesFromOptions() for more complex scenarios (see grafonnet docs)

  Panel-specific options (use actual values from reference panel):

  stat panels (g.panel.stat):
  panelName:
    g.panel.stat.new('Title')
    + g.panel.stat.panelOptions.withDescription('...')
    + g.panel.stat.queryOptions.withTargets([
      signals.xxx.yyy.asTarget()
      + g.query.prometheus.withIntervalFactor(2),
    ])
    + g.panel.stat.standardOptions.color.withMode('thresholds')
    + g.panel.stat.standardOptions.withMappings([...])  // or [] for empty
    + g.panel.stat.standardOptions.thresholds.withMode('absolute')
    + g.panel.stat.standardOptions.thresholds.withSteps([...])
    + g.panel.stat.standardOptions.withUnit('...')  // if applicable
    + g.panel.stat.standardOptions.withOverrides([])
    + g.panel.stat.options.withColorMode('value')
    + g.panel.stat.options.withGraphMode('none')
    + g.panel.stat.options.withJustifyMode('auto')
    + g.panel.stat.options.withOrientation('auto')
    + g.panel.stat.options.reduceOptions.withCalcs(['lastNotNull'])  // CHAINED format
    + g.panel.stat.options.reduceOptions.withFields('')
    + g.panel.stat.options.reduceOptions.withValues(false)
    + g.panel.stat.options.withTextMode('auto'),

  barGauge panels (g.panel.barGauge):
  panelName:
    g.panel.barGauge.new('Title')
    + g.panel.barGauge.panelOptions.withDescription('...')
    + g.panel.barGauge.queryOptions.withTargets([...])
    + g.panel.barGauge.standardOptions.color.withMode('thresholds')
    + g.panel.barGauge.standardOptions.withMappings([])
    + g.panel.barGauge.standardOptions.thresholds.withMode('absolute')
    + g.panel.barGauge.standardOptions.thresholds.withSteps([...])
    + g.panel.barGauge.standardOptions.withUnit('...')
    + g.panel.barGauge.standardOptions.withMax(...)  // if applicable
    + g.panel.barGauge.standardOptions.withMin(...)  // if applicable
    + g.panel.barGauge.standardOptions.withOverrides([])
    + g.panel.barGauge.options.withDisplayMode('gradient')
    + g.panel.barGauge.options.withMinVizHeight(10)  // if applicable
    + g.panel.barGauge.options.withMinVizWidth(0)    // if applicable
    + g.panel.barGauge.options.withShowUnfilled(true) // if applicable
    + g.panel.barGauge.options.reduceOptions.withCalcs(['lastNotNull'])  // CHAINED format
    + g.panel.barGauge.options.reduceOptions.withFields('')
    + g.panel.barGauge.options.reduceOptions.withValues(false)
    + g.panel.barGauge.options.withOrientation('horizontal'),

  timeSeries panels (g.panel.timeSeries):
  panelName:
    g.panel.timeSeries.new('Title')
    + g.panel.timeSeries.panelOptions.withDescription('...')
    + g.panel.timeSeries.queryOptions.withTargets([...])
    + g.panel.timeSeries.standardOptions.color.withMode('palette-classic')
    + g.panel.timeSeries.standardOptions.withMappings([])
    + g.panel.timeSeries.standardOptions.thresholds.withMode('absolute')
    + g.panel.timeSeries.standardOptions.thresholds.withSteps([
      g.panel.timeSeries.standardOptions.threshold.step.withColor('green')
      + g.panel.timeSeries.standardOptions.threshold.step.withValue(null),
    ])
    + g.panel.timeSeries.standardOptions.withUnit('...')
    + g.panel.timeSeries.standardOptions.withOverrides([])
    + g.panel.timeSeries.fieldConfig.defaults.custom.withAxisCenteredZero(false)
    + g.panel.timeSeries.fieldConfig.defaults.custom.withAxisColorMode('text')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withAxisLabel('')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withAxisPlacement('auto')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withBarAlignment(0)
    + g.panel.timeSeries.fieldConfig.defaults.custom.withDrawStyle('line')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withFillOpacity(0)
    + g.panel.timeSeries.fieldConfig.defaults.custom.withGradientMode('none')
    + g.panel.timeSeries.fieldConfig.defaults.custom.hideFrom.withLegend(false)
    + g.panel.timeSeries.fieldConfig.defaults.custom.hideFrom.withTooltip(false)
    + g.panel.timeSeries.fieldConfig.defaults.custom.hideFrom.withViz(false)
    + g.panel.timeSeries.fieldConfig.defaults.custom.withLineInterpolation('linear')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withLineWidth(1)
    + g.panel.timeSeries.fieldConfig.defaults.custom.withPointSize(5)
    + g.panel.timeSeries.fieldConfig.defaults.custom.scaleDistribution.withType('linear')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withShowPoints('auto')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withSpanNulls(false)
    + g.panel.timeSeries.fieldConfig.defaults.custom.stacking.withGroup('A')
    + g.panel.timeSeries.fieldConfig.defaults.custom.stacking.withMode('none')
    + g.panel.timeSeries.fieldConfig.defaults.custom.thresholdsStyle.withMode('off')
    + g.panel.timeSeries.options.legend.withCalcs([])
    + g.panel.timeSeries.options.legend.withDisplayMode('list')
    + g.panel.timeSeries.options.legend.withPlacement('bottom')
    + g.panel.timeSeries.options.legend.withShowLegend(true)
    + g.panel.timeSeries.options.tooltip.withMode('single')
    + g.panel.timeSeries.options.tooltip.withSort('none'),

  table panels (g.panel.table):
    - Check for transformations (labelsToFields, merge, organize) - use actual transformations from reference
    - Check for column overrides and custom cell options - use actual overrides from reference
    - Check for value mappings using the ValueMap pattern above - use actual mappings from reference

  statusHistory panels (g.panel.statusHistory):
    - options.withShowValue('never') (use actual value from reference)
    - options.withLegend(false) (use actual value from reference)
    - queryOptions.withMaxDataPoints(100) (use actual value from reference)
    - Check for value mappings using the ValueMap pattern above - use actual mappings from reference
  6. Build and compare the generated output:

  6. a. Run make all in the opensearch-mixin directory to generate the JSON output

  6. b. Extract both panels for comparison:
  jq '.panels[] | select(.title == "[PANEL_TITLE]")' opensearch-mixin/dashboards_out/[DASHBOARD_NAME].json > /tmp/new_panel.json
  jq '.panels[] | select(.title == "[PANEL_TITLE]")' [LEGACY_JSON_PATH] > /tmp/legacy_panel.json

  6. c. Compare the panels excluding auto-generated fields:
  diff -u \
    <(jq --sort-keys 'del(.gridPos, .id, .pluginVersion, .datasource, .targets[0].datasource, .targets[0].instant, .targets[0].refId)' /tmp/legacy_panel.json) \
    <(jq --sort-keys 'del(.gridPos, .id, .pluginVersion, .datasource, .targets[0].datasource, .targets[0].instant, .targets[0].refId)' /tmp/new_panel.json)

  6. d. Analyze differences:
    - Ignore cosmetic differences like expression formatting (newlines/spaces)
    - Identify any missing fields or incorrect values
    - If differences exist, go back to step 3-5 and add the missing configuration

  e. Repeat until the panels match - Continue iterating through steps 3-6 until the diff shows only acceptable differences (formatting, auto-generated fields)
  7. Important notes:
    - Always add withMappings([]) if the reference has an empty array
    - Always add withOverrides([]) if the reference has an empty array
    - Always add thresholds.withMode('absolute')
    - Always use chained format for reduceOptions (NOT object format)
    - Don't worry about the "format": "time_series" field - that's automatically handled
    - Grid position (gridPos) is managed by dashboard layout - don't include that
    - Panel IDs are auto-generated - don't include those
    - For mappings, use the mapping.ValueMap builder but the options hash structure is required
    - Always use the actual values from the reference panel, not the example values shown above
    - Always update both the signal definition AND the panel definition to match the legacy JSON
    - Pay close attention to whether the legacy uses queriesSelector or queriesSelectorGroupOnly - check the actual label selectors in the metric
    - Property ordering matters:
        - color.withMode() comes BEFORE thresholds
      - thresholds.withMode() comes immediately after withMappings()
      - withUnit() comes AFTER thresholds
      - withOverrides() always at end of standardOptions
    - The only acceptable differences should be:
        - Expression formatting (newlines/whitespace)
      - Auto-generated fields (id, gridPos, pluginVersion)
      - Datasource structure differences from the signal framework
  8. Final output - Show the comparison:

  8. After completing all updates and verifying the panels match, provide the following output:

  8. a. Summary of changes made to signals and panels

  8. b. Full JSON comparison showing:
    - The legacy panel JSON from the legacy dashboard
    - The new generated panel JSON from opensearch-mixin/dashboards_out/
    - A diff comparison highlighting any remaining differences

  c. Verification statement confirming that all significant fields match and only acceptable differences remain

