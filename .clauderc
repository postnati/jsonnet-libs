CRITICAL: ALWAYS follow the complete workflow including step 7 (comparison). DO NOT skip the comparison step.

1. Identify the panel in opensearch-mixin/panels.libsonnet and determine its type (stat, barGauge, timeSeries, table, etc.)
  2. Locate the legacy reference panel:
    - Find the corresponding dashboard in opensearch-mixin-legacy/dashboards_out/ (NOT dashboards/)
    - Extract the panel JSON by title: jq '.panels[] | select(.title == "TITLE")' legacy.json
    - This becomes the source of truth for all comparisons
  3. Compare and update the signal definition:

  3. a. Examine the target expression in the legacy JSON panel's targets[0].expr field

  3. b. Identify the signal used in the current panel (e.g., signals.cluster.cluster_status)

  3. c. Find the signal definition in the appropriate signals file (e.g., opensearch-mixin/signals/cluster.libsonnet)

  3. d. Update the signal properties to match the legacy expression:

    IMPORTANT: Use signal framework helpers for simple aggregations instead of type: 'raw'

    - type: Set to 'gauge', 'counter', or 'raw'
      - Use 'gauge' for current values that can go up or down (e.g., cpu_percent, memory_bytes)
      - Use 'counter' for monotonically increasing values (e.g., request_count, evictions_count)
      - Use 'raw' ONLY for complex expressions with multiple operations (division, clamp_min, etc.)

    - aggLevel: Controls the aggregation scope (when type is 'gauge' or 'counter')
      - 'group' → aggregates by job,opensearch_cluster (groupLabels only)
      - 'instance' → aggregates by job,opensearch_cluster,node (groupLabels + instanceLabels)
      - 'none' → no automatic aggregation wrapper

    - aggFunction: The aggregation function to use (when type is 'gauge' or 'counter')
      - 'min', 'max', 'avg', 'sum' → generates min by(...), max by(...), etc.
      - Framework automatically wraps the expr with: aggFunction by (labels) (expr)

    - aggKeepLabels: Additional labels to preserve in aggregation (e.g., ['index'], ['type'])
      - Example: aggKeepLabels: ['index'] generates avg by (job,opensearch_cluster,index) (...)
      - Without this, you get avg by (job,opensearch_cluster) (...)

    - rangeFunction: For counter metrics that need increase() or rate() (when type is 'counter')
      - 'increase' → wraps expr with increase(expr[$__interval:] offset -$__interval)
      - 'rate' → wraps expr with rate(expr[$__rate_interval])
      - Framework handles the range window and offset automatically
      - IMPORTANT: When using rangeFunction, DO NOT include increase() or rate() in expr

    - legendCustomTemplate: Must match the legendFormat from legacy JSON
      - Example: '{{opensearch_cluster}}', '{{node}}', '{{type}}', '{{index}}'
      - IMPORTANT: No spaces around label names: '{{index}}' NOT '{{ index }}'

    Examples of when to use each approach:

    Example 1: Simple gauge aggregation (USE FRAMEWORK HELPERS)
    Legacy expr: avg by (job,opensearch_cluster,index) (opensearch_index_search_query_current_number{...})

    OLD (type: 'raw'):
      type: 'raw',
      expr: 'avg by (job,opensearch_cluster,index) (opensearch_index_search_query_current_number{%(queriesSelectorGroupOnly)s,index=~"$index"})',

    NEW (use framework):
      type: 'gauge',
      aggLevel: 'group',
      aggFunction: 'avg',
      expr: 'opensearch_index_search_query_current_number{%(queriesSelectorGroupOnly)s,index=~"$index"}',
      aggKeepLabels: ['index'],

    Example 2: Counter with increase (USE FRAMEWORK HELPERS)
    Legacy expr: avg by (job,opensearch_cluster,index) (increase(opensearch_index_querycache_evictions_count{...}[$__interval:]))

    OLD (type: 'raw'):
      type: 'raw',
      expr: 'avg by (job,opensearch_cluster,index) (increase(opensearch_index_querycache_evictions_count{%(queriesSelector)s}[$__interval:]))',

    NEW (use framework):
      type: 'counter',
      aggLevel: 'group',
      aggFunction: 'avg',
      expr: 'opensearch_index_querycache_evictions_count{%(queriesSelector)s}',
      rangeFunction: 'increase',
      aggKeepLabels: ['index'],

    Example 3: Complex expression (MUST USE 'raw')
    Legacy expr: avg by (job,opensearch_cluster,index) (increase(time_seconds{...})[$__interval:] / clamp_min(increase(count{...})[$__interval:], 1))

    MUST use type: 'raw' because:
    - Has division operation
    - Has clamp_min() function
    - Uses multiple metrics
    - Cannot be expressed with simple aggregation + rangeFunction

    Keep as:
      type: 'raw',
      expr: 'avg by (job,opensearch_cluster,index) (increase(opensearch_index_search_query_time_seconds{%(queriesSelectorGroupOnly)s,index=~"$index"}[$__interval:]) / clamp_min(increase(opensearch_index_search_query_count{%(queriesSelectorGroupOnly)s,index=~"$index"}[$__interval:]), 1))',

    Rule of thumb:
    - If legacy has ONLY: avg/sum/min/max by (...) (metric{...}) → use type: 'gauge' with helpers
    - If legacy has ONLY: avg/sum/min/max by (...) (increase/rate(metric{...})) → use type: 'counter' with rangeFunction
    - If legacy has: division, multiplication, addition, clamp_min, or multiple metrics → use type: 'raw'
    - IMPORTANT - Selector template variables (%(queriesSelector)s and %(queriesSelectorGroupOnly)s):
        - These template variables are substituted during the build process
      - They are constructed from the mixin's groupLabels and instanceLabels configuration

      Understanding the mixin configuration (opensearch-mixin/config.libsonnet):
      - groupLabels: ['job', 'opensearch_cluster'] (or ['job', 'cluster', 'opensearch_cluster'] with multi-cluster)
      - instanceLabels: ['node']

      Template variable substitutions:
      - %(queriesSelectorGroupOnly)s expands to: opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster"
        - This uses ONLY the groupLabels (job, opensearch_cluster)
        - Use when you need to filter by cluster-level labels without instance filtering
        - Example: opensearch_cluster_status{%(queriesSelectorGroupOnly)s}
          becomes: opensearch_cluster_status{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster"}

      - %(queriesSelector)s expands to: opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster",node=~"$node"
        - This uses groupLabels + instanceLabels (job, opensearch_cluster, node)
        - Use when you need to filter by both cluster and instance (node) labels
        - Example: opensearch_os_cpu_percent{%(queriesSelector)s}
          becomes: opensearch_os_cpu_percent{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster",node=~"$node"}

      Adding additional filters:
      - You can add extra label filters after the template variable
      - Use a comma to separate: {%(queriesSelectorGroupOnly)s,index=~"$index"}
      - Example: opensearch_index_search_query_current_number{%(queriesSelectorGroupOnly)s,index=~"$index", context=~"total"}
        becomes: opensearch_index_search_query_current_number{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster",index=~"$index", context=~"total"}

      Rule of thumb for choosing the right selector:
      - Use %(queriesSelectorGroupOnly)s when:
        - The metric is cluster-scoped (doesn't vary by node)
        - OR you want to aggregate across all nodes first, then filter
        - Examples: cluster_status, cluster_nodes_number, or index-level metrics aggregated across nodes
      - Use %(queriesSelector)s when:
        - The metric is node-scoped (varies by node)
        - You want to filter by specific nodes using the $node dashboard variable
        - Examples: os_cpu_percent, os_mem_used_percent, jvm_heap_used_bytes

  e. Compare generated vs legacy expression:
    - Signal with aggLevel: 'group', aggFunction: 'min' generates:
    min by(job,opensearch_cluster) (opensearch_metric{opensearch_cluster!="",job=~"$job",opensearch_cluster=~"$opensearch_cluster"})
    - If the legacy has additional wrappers like sum(max by (type) (...)), use withExprWrappersMixin() in the panel

  f. Update the panel's signal usage if needed:
    - Basic: signals.cluster.signal_name.asTarget()
    - With wrappers: signals.cluster.signal_name.withExprWrappersMixin(['sum(', ')']).asTarget()
    - Multiple wrappers can be nested: withExprWrappersMixin(['sum(', ')'])
  4. Compare and update missing panel configuration options in the current libsonnet, specifically:
    - Missing options properties (varies by panel type - see below)
    - Missing standardOptions properties (color mode, mappings, thresholds mode, overrides)
    - Missing target properties (intervalFactor, interval, instant)

  4.1. IMPORTANT - Simplification and Default Values:
    - The legacy JSON panels include ALL Grafana default values explicitly because that's how Grafana exports dashboards
    - Following Jsonnet mixin best practices, ONLY include non-default values in your panel definitions
    - This keeps the code clean, maintainable, and focused on meaningful customizations
    - When reviewing existing panel code, identify and remove any default values that provide no customization

    HOW TO IDENTIFY DEFAULT VALUES:
    - Compare settings to the default values list below
    - If a setting matches a default exactly, remove it
    - Even in modernized panels, default values may still exist (e.g., color.withMode('palette-classic'))
    - ALWAYS remove these when found, even if the panel has other meaningful customizations

    Common Grafana defaults to OMIT (unless the legacy has a different value):
    - color.withMode('palette-classic') - this is the default color mode, ALWAYS remove
    - withMappings([]) - empty mappings array is default
    - thresholds.withMode('absolute') - default threshold mode
    - thresholds.withSteps([{color: 'green', value: null}]) - default threshold (single green step)
    - withOverrides([]) - empty overrides array is default
    - All stat panel defaults:
      - options.withColorMode('value'), withGraphMode('none'), withJustifyMode('auto'), withOrientation('auto')
      - options.withTextMode('auto')
      - reduceOptions.withFields(''), withValues(false)
    - All barGauge panel defaults:
      - options.withDisplayMode('gradient'), withMinVizHeight(10), withMinVizWidth(0)
      - options.withOrientation('horizontal'), withShowUnfilled(true)
      - reduceOptions.withFields(''), withValues(false)
    - All timeSeries custom field defaults:
      - withAxisCenteredZero(false), withAxisColorMode('text'), withAxisLabel(''), withAxisPlacement('auto')
      - withBarAlignment(0), withDrawStyle('line'), withFillOpacity(0), withGradientMode('none')
      - hideFrom.withLegend(false), hideFrom.withTooltip(false), hideFrom.withViz(false)
      - withLineInterpolation('linear'), withLineWidth(1), withPointSize(5)
      - scaleDistribution.withType('linear'), withShowPoints('auto'), withSpanNulls(false)
      - stacking.withGroup('A'), stacking.withMode('none'), thresholdsStyle.withMode('off')
    - All legend defaults:
      - legend.withCalcs([]), legend.withDisplayMode('list'), legend.withPlacement('bottom'), legend.withShowLegend(true)
    - All tooltip defaults:
      - tooltip.withMode('single'), tooltip.withSort('none')

    Values to INCLUDE (these are meaningful customizations):
    - Non-default color modes (e.g., 'continuous-BlYlRd', 'thresholds')
      - NOTE: 'palette-classic' is the DEFAULT - never include it!
    - Non-empty mappings with actual value mappings
    - Custom thresholds with multiple steps or non-green colors
    - Non-empty overrides with field-specific customizations
    - Custom intervals (e.g., withInterval('1m'))
    - Custom intervalFactor (e.g., withIntervalFactor(2))
    - Meaningful units (e.g., withUnit('percent'), withUnit('bytes'))
    - Custom min/max values (e.g., withMin(0), withMax(100))
    - Custom decimals (e.g., withDecimals(1))
    - Non-default timeSeries styling:
      - Custom fillOpacity (e.g., 5, 30) - default is 0
      - Custom gradientMode (e.g., 'scheme', 'opacity') - default is 'none'
      - Custom lineInterpolation (e.g., 'smooth') - default is 'linear'
      - Custom lineWidth (e.g., 2) - default is 1
      - Custom showPoints (e.g., 'never') - default is 'auto'
      - Custom stacking mode (e.g., 'normal') - default is 'none'
    - Non-default legend options:
      - Custom displayMode (e.g., 'table') - default is 'list'
      - Custom calcs with values (e.g., ['mean', 'lastNotNull']) - default is []
    - Non-default tooltip options:
      - Custom mode (e.g., 'multi') - default is 'single'
      - Custom sort (e.g., 'desc') - default is 'none'

  5. Update the libsonnet panel definition to include ONLY MEANINGFUL non-default properties using the appropriate grafonnet helper methods based on panel type. Use the actual values from the reference panel - the examples below are just to show the
  syntax:

  5. For all panel types (ONLY include if non-default):
    - Use g.query.prometheus.withIntervalFactor(2) ONLY if not default (1)
    - Use g.query.prometheus.withInterval('1m') ONLY if specified in reference
    - Use g.query.prometheus.withInstant(true) ONLY if instant queries are used
    - Use g.panel.[TYPE].standardOptions.color.withMode('...') ONLY if NOT 'palette-classic'
    - OMIT g.panel.[TYPE].standardOptions.thresholds.withMode('absolute') - it's the default
    - OMIT g.panel.[TYPE].standardOptions.withOverrides([]) - empty is the default

  For mappings (ONLY include if non-default):
    - OMIT withMappings([]) - empty array is the default
    - ONLY include if the panel has actual value mappings, use the ValueMap builder pattern with the actual mapping values from the reference panel:
    + g.panel.[TYPE].standardOptions.withMappings([
    g.panel.[TYPE].standardOptions.mapping.ValueMap.withType()
    + g.panel.[TYPE].standardOptions.mapping.ValueMap.withOptions({
      '0': {index: 0, text: 'Green'},  // Use actual values from reference
      '1': {index: 1, text: 'Yellow'},
      '2': {index: 2, text: 'Red'},
    }),
  ])
    - Note: The options hash with specific keys is unavoidable - that's how Grafana mappings work.

  For overrides (ONLY include if non-default):
    - ALWAYS use the fieldOverride builder methods instead of hardcoded data structures
    - OMIT withOverrides([]) - empty array is the default
    - ONLY include if the panel has actual overrides, use the fieldOverride builder pattern:
    + g.panel.[TYPE].standardOptions.withOverrides([
    g.panel.[TYPE].fieldOverride.byRegexp.new('/pattern/')  // or byName, byType, byQuery
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('custom.axisSoftMax', 100)
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('custom.drawStyle', 'points')
    + g.panel.[TYPE].fieldOverride.byRegexp.withProperty('unit', 'percent'),
  ])
    - Available override matchers: byRegexp, byName, byType, byQuery (byFrameRefID), byValue
    - Use withProperty(id, value) to add individual properties
    - Use withPropertiesFromOptions() for more complex scenarios (see grafonnet docs)

  Panel-specific options (use actual values from reference panel):

  stat panels (g.panel.stat):
  panelName:
    g.panel.stat.new('Title')
    + g.panel.stat.panelOptions.withDescription('...')
    + g.panel.stat.queryOptions.withTargets([
      signals.xxx.yyy.asTarget()
      + g.query.prometheus.withIntervalFactor(2),
    ])
    + g.panel.stat.standardOptions.color.withMode('thresholds')
    + g.panel.stat.standardOptions.withMappings([...])  // or [] for empty
    + g.panel.stat.standardOptions.thresholds.withMode('absolute')
    + g.panel.stat.standardOptions.thresholds.withSteps([...])
    + g.panel.stat.standardOptions.withUnit('...')  // if applicable
    + g.panel.stat.standardOptions.withOverrides([])
    + g.panel.stat.options.withColorMode('value')
    + g.panel.stat.options.withGraphMode('none')
    + g.panel.stat.options.withJustifyMode('auto')
    + g.panel.stat.options.withOrientation('auto')
    + g.panel.stat.options.reduceOptions.withCalcs(['lastNotNull'])  // CHAINED format
    + g.panel.stat.options.reduceOptions.withFields('')
    + g.panel.stat.options.reduceOptions.withValues(false)
    + g.panel.stat.options.withTextMode('auto'),

  barGauge panels (g.panel.barGauge):
  panelName:
    g.panel.barGauge.new('Title')
    + g.panel.barGauge.panelOptions.withDescription('...')
    + g.panel.barGauge.queryOptions.withTargets([...])
    + g.panel.barGauge.standardOptions.color.withMode('thresholds')
    + g.panel.barGauge.standardOptions.withMappings([])
    + g.panel.barGauge.standardOptions.thresholds.withMode('absolute')
    + g.panel.barGauge.standardOptions.thresholds.withSteps([...])
    + g.panel.barGauge.standardOptions.withUnit('...')
    + g.panel.barGauge.standardOptions.withMax(...)  // if applicable
    + g.panel.barGauge.standardOptions.withMin(...)  // if applicable
    + g.panel.barGauge.standardOptions.withOverrides([])
    + g.panel.barGauge.options.withDisplayMode('gradient')
    + g.panel.barGauge.options.withMinVizHeight(10)  // if applicable
    + g.panel.barGauge.options.withMinVizWidth(0)    // if applicable
    + g.panel.barGauge.options.withShowUnfilled(true) // if applicable
    + g.panel.barGauge.options.reduceOptions.withCalcs(['lastNotNull'])  // CHAINED format
    + g.panel.barGauge.options.reduceOptions.withFields('')
    + g.panel.barGauge.options.reduceOptions.withValues(false)
    + g.panel.barGauge.options.withOrientation('horizontal'),

  timeSeries panels (g.panel.timeSeries) - SIMPLIFIED APPROACH:
  Basic timeSeries with defaults (most common):
    g.panel.timeSeries.new('Title')
    + g.panel.timeSeries.panelOptions.withDescription('...')
    + g.panel.timeSeries.queryOptions.withTargets([
      signals.xxx.yyy.asTarget()
      + g.query.prometheus.withInterval('1m')  // ONLY if non-default
      + g.query.prometheus.withIntervalFactor(2),  // ONLY if non-default (not 1)
    ])
    + g.panel.timeSeries.standardOptions.withUnit('...'),  // ONLY include meaningful unit

  timeSeries with custom styling (if legacy has non-defaults):
    g.panel.timeSeries.new('Title')
    + g.panel.timeSeries.panelOptions.withDescription('...')
    + g.panel.timeSeries.queryOptions.withTargets([...])
    + g.panel.timeSeries.standardOptions.color.withMode('continuous-BlYlRd')  // ONLY if not 'palette-classic'
    + g.panel.timeSeries.standardOptions.withDecimals(1)  // ONLY if specified
    + g.panel.timeSeries.standardOptions.withMax(100)  // ONLY if specified
    + g.panel.timeSeries.standardOptions.withMin(0)  // ONLY if specified
    + g.panel.timeSeries.standardOptions.withUnit('percent')
    + g.panel.timeSeries.fieldConfig.defaults.custom.withFillOpacity(5)  // ONLY if not 0
    + g.panel.timeSeries.fieldConfig.defaults.custom.withGradientMode('scheme')  // ONLY if not 'none'
    + g.panel.timeSeries.fieldConfig.defaults.custom.withLineInterpolation('smooth')  // ONLY if not 'linear'
    + g.panel.timeSeries.fieldConfig.defaults.custom.withLineWidth(2)  // ONLY if not 1
    + g.panel.timeSeries.fieldConfig.defaults.custom.withShowPoints('never')  // ONLY if not 'auto'
    + g.panel.timeSeries.fieldConfig.defaults.custom.stacking.withMode('normal')  // ONLY if not 'none'
    + g.panel.timeSeries.options.legend.withCalcs(['mean', 'lastNotNull'])  // ONLY if not empty
    + g.panel.timeSeries.options.tooltip.withMode('multi')  // ONLY if not 'single'
    + g.panel.timeSeries.options.tooltip.withSort('desc'),  // ONLY if not 'none'

  table panels (g.panel.table):
    - Check for transformations (labelsToFields, merge, organize) - use actual transformations from reference
    - Check for column overrides and custom cell options - use actual overrides from reference
    - Check for value mappings using the ValueMap pattern above - use actual mappings from reference

  statusHistory panels (g.panel.statusHistory):
    - options.withShowValue('never') (use actual value from reference)
    - options.withLegend(false) (use actual value from reference)
    - queryOptions.withMaxDataPoints(100) (use actual value from reference)
    - Check for value mappings using the ValueMap pattern above - use actual mappings from reference

  6. Condense data structures for readability:

  IMPORTANT: After creating panel definitions, condense simple data structures to reduce line count and improve readability.
  Follow these guidelines for when and how to condense:

  6.1. When to condense (put on single lines):
    - Simple objects with 2-4 properties where each property has a scalar value
    - Transformation objects like {id: 'merge', options: {}}
    - Mapping entries with 3-4 properties like {color: 'green', index: 0, text: 'Active'}
    - Simple nested objects within larger structures
    - Object comprehensions that fit comfortably on one line

  6.2. When NOT to condense (keep multi-line):
    - Objects with complex nested structures
    - Objects with more than 4-5 properties
    - Lines that would exceed ~120 characters
    - Grafonnet builder chains (always keep these multi-line with + operators)
    - Function definitions or complex logic

  6.3. Examples of good condensing:

  Transformations - BEFORE (verbose):
    + g.panel.table.queryOptions.withTransformations([
      {
        id: 'labelsToFields',
        options: {
          mode: 'columns',
          valueLabel: 'role',
        },
      },
      {
        id: 'merge',
        options: {},
      },
    ])

  Transformations - AFTER (condensed):
    + g.panel.table.queryOptions.withTransformations([
      {id: 'labelsToFields', options: {mode: 'columns', valueLabel: 'role'}},
      {id: 'merge', options: {}},
    ])

  Mappings - BEFORE (verbose):
    '0': {
      color: 'super-light-orange',
      index: 5,
      text: 'False',
    },
    '1': {
      color: 'light-green',
      index: 3,
      text: 'True',
    },

  Mappings - AFTER (condensed):
    '0': {color: 'super-light-orange', index: 5, text: 'False'},
    '1': {color: 'light-green', index: 3, text: 'True'},

  Large objects split across multiple lines - BEFORE (verbose):
    indexByName: {
      Time: 0,
      node: 3,
      nodeid: 3,
      master: 104,
      data: 105,
      ingest: 106,
      remote_cluster_client: 107,
      cluster_manager: 108,
    }

  Large objects split across multiple lines - AFTER (condensed):
    indexByName: {
      Time: 0, node: 3, nodeid: 3, master: 104, data: 105,
      ingest: 106, remote_cluster_client: 107, cluster_manager: 108,
    }

  Object comprehensions - BEFORE (verbose):
    } + {
      [k]: 3
      for k in this.config.groupLabels + this.config.instanceLabels
    }

  Object comprehensions - AFTER (condensed):
    } + {[k]: 3 for k in this.config.groupLabels + this.config.instanceLabels}

  Override properties - BEFORE (verbose):
    + g.panel.table.fieldOverride.byRegexp.withProperty('custom.cellOptions', {
      type: 'color-text',
    })

  Override properties - AFTER (condensed):
    + g.panel.table.fieldOverride.byRegexp.withProperty('custom.cellOptions', {type: 'color-text'})

  6.4. Benefits of condensing:
    - Reduces vertical space, allowing more code to fit on screen
    - Makes panel structure easier to scan and understand at a glance
    - Reduces file size and improves git diffs
    - Maintains readability for simple structures while avoiding excessive line breaks
    - Typical reduction: 40-60% fewer lines for panels with transformations/mappings

  6.5. Important: DO NOT condense grafonnet builder chains
    - Always keep builder chains multi-line with one method per line
    - This maintains readability of the configuration flow

  GOOD (builder chains stay multi-line):
    g.panel.table.new('Roles')
    + g.panel.table.panelOptions.withDescription('...')
    + g.panel.table.queryOptions.withTargets([...])
    + g.panel.table.standardOptions.withMappings([...])

  BAD (don't condense builder chains):
    g.panel.table.new('Roles') + g.panel.table.panelOptions.withDescription('...') + g.panel.table.queryOptions.withTargets([...])

  7. Build and compare the generated output:

  ⚠️ CRITICAL: This step is MANDATORY. DO NOT skip it. Even if you think the panel is correct,
  you MUST build and compare to verify. Missing configurations are common and only caught by comparison.

  7.a. Run make dashboards_out in the opensearch-mixin directory to generate the JSON output

  7.b. Extract both panels for comparison:
  cd /path/to/opensearch-jsonnet-libs  # Go to repo root
  jq '.panels[] | select(.title == "[PANEL_TITLE]")' opensearch-mixin-legacy/dashboards_out/[DASHBOARD_NAME].json > /tmp/legacy_panel.json
  jq '.panels[] | select(.title == "[PANEL_TITLE]")' opensearch-mixin/dashboards_out/[DASHBOARD_NAME].json > /tmp/new_panel.json

  7.c. Compare the panels excluding auto-generated fields:
  diff -u \
    <(jq --sort-keys 'del(.gridPos, .id, .pluginVersion, .datasource, .targets[].datasource, .targets[].instant, .targets[].refId)' /tmp/legacy_panel.json) \
    <(jq --sort-keys 'del(.gridPos, .id, .pluginVersion, .datasource, .targets[].datasource, .targets[].instant, .targets[].refId)' /tmp/new_panel.json)

  Note: Use .targets[] (with brackets) to handle multiple targets correctly.

  7.d. Analyze differences - Common missing items that comparison catches:
    - Field overrides (byName, byRegexp, byValue matchers)
    - Custom legend formats in signals (legendCustomTemplate)
    - Wrong selector template variable (queriesSelector vs queriesSelectorGroupOnly)
    - Missing label filters in signal expressions (e.g., index=~"$index")
    - Non-default tooltip/legend options
    - Ignore cosmetic differences like expression formatting (newlines/spaces)
    - Signal framework differences (offset -$__interval added automatically)
    - If differences exist, go back to step 3-5 and add the missing configuration

  7.e. Repeat until the panels match - Continue iterating through steps 3-7 until the diff shows only acceptable differences (formatting, auto-generated fields, signal framework patterns)

  8. Important notes:
    - OMIT withMappings([]) - empty array is default (only include if has actual mappings)
    - OMIT withOverrides([]) - empty array is default (only include if has actual overrides)
    - OMIT thresholds.withMode('absolute') - it's the default
    - OMIT all timeSeries custom field defaults (see section 4.1 for full list)
    - OMIT default legend/tooltip options (see section 4.1 for full list)
    - Always use chained format for reduceOptions (NOT object format)
    - Don't worry about the "format": "time_series" field - that's automatically handled
    - Grid position (gridPos) is managed by dashboard layout - don't include that
    - Panel IDs are auto-generated - don't include those
    - For mappings, use the mapping.ValueMap builder but the options hash structure is required
    - For overrides, use the fieldOverride builder methods (see section 5)
    - ONLY include non-default values from the reference panel (see section 4.1)
    - After creating panels, condense simple data structures (see section 6)
    - Always update both the signal definition AND the panel definition to match the legacy JSON
    - Pay close attention to whether the legacy uses queriesSelector or queriesSelectorGroupOnly - check the actual label selectors in the metric
    - Property ordering for non-defaults that you DO include:
        - color.withMode() comes first if non-default
      - withDecimals(), withMax(), withMin() before withUnit()
      - withUnit() always included if meaningful
      - Custom field properties grouped together
      - Legend options grouped together
      - Tooltip options grouped together
    - The acceptable differences will be MORE than just formatting:
        - Expression formatting (newlines/whitespace)
      - Auto-generated fields (id, gridPos, pluginVersion)
      - Datasource structure differences from the signal framework
      - ALL the default values that are in legacy JSON but omitted from simplified Jsonnet
      - The generated JSON will be much shorter because Grafana adds defaults when loading

  9. Final output - Show the comparison:

  9.a. After completing all updates and verifying the panels match, provide the following output:

  9.b. Summary of changes made to signals and panels

  9.c. Full JSON comparison showing:
    - The legacy panel JSON from the legacy dashboard
    - The new generated panel JSON from opensearch-mixin/dashboards_out/
    - A diff comparison highlighting any remaining differences

  9.d. Verification statement confirming that all significant fields match and only acceptable differences remain

